# Developing for DecaLog

Before starting to explain how to use DecaLog from a developer point of view, I would like to thank you to take the time to invest your knowledge and skills in making DecaLog better and more useful. I'll only have one word: you rock! (OK, that's two words)

Now, what's the menu today?

1. [What is DecaLog?](#what-is-decalog)
2. [Definitions](#definitions)
3. [Anatomy of an event](#anatomy-of-an-event)
4. [Coding with DecaLog](#coding-with-decalog)
5. [Conventions](#conventions)
6. [Contribution Guidelines](/CONTRIBUTING.md)
7. [Code of Conduct](/CODE_OF_CONDUCT.md)

## What is DecaLog?
DecaLog is WordPress plugin which that to:
- capture events generated by the core of WordPress and themes / plugins;
- enrich these events with many details regarding their triggering;
- record these events in the WordPress database and/or send them to external services for logging, monitoring and alerting;
- view (and filter) events recorded in the WordPress database.

## Definitions
When using (and developing for) DecaLog, you will have to deal with the following notions:
- __Event__ - An event is some bits of information regarding something which happened while executing WordPress. See [Anatomy of an event](#anatomy-of-an-event) to know what it's made of.
- __Listener__ - A listener is, as its name suggests, something that listens to what's going on in a specific _perimeter_ (mainly a specific WordPress component or subsystem), make it an ___event___ and pass this ___event___ to the running ___loggers___.
- __Logger__ - A logger is a _recorder_ of ___events___. It can filter them (accept or refuse to record the ___event___ based on settings) then store them (in a database, a file, etc.) or send them (via API calls, sockets, mails, etc.).

## Anatomy of an event
An ___event___ is composed of:
- A __channel__, which is the type of "execution pipe" that triggered the ___event___. It can take the following values: `CLI` (command-line interface), `CRON` (cron job), `AJAX` (Ajax request), `XMLRPC` (XML-RPC request), `API` (Rest API request), `FEED` (Atom/RDF/RSS feed), `WBACK` (site backend), `WFRONT` (site frontend).
- A __level__, which represents the severity of the ___event___. This level is set by the ___listener___, regarding what triggered the ___event___. It can take the following values (from the lowest severity to the highest severity): `DEBUG`, `INFO`, `NOTICE`, `WARNING`, `ERROR`, `CRITICAL`, `ALERT`, `EMERGENCY`. For a detail on how it is used, please read "Events standards" in [Conventions](#conventions).
- A __timestamp__, which is the time when ___event___ was triggered.
- A versioned __source__, which is the component or the subsystem where the ___event___ is triggered. It maybe things like `PHP`/`7.2` or `WordPress`/`5.2.2` and so on...
- The __class__ of the source, which can take the following values: `core`, `plugin`, `theme`, `db`, `php`.
- A __message__ in plain text. It is always in English: messages are not localized.
- A numerical __code__, which may be everything which makes sense regarding the ___event___ (an error code, for instance).

Depending on each ___loggers___ settings, an ___event___ may contains many other fields which are automaticaly detected and filled by DecaLog.


## Coding with DecaLog
In fact, as a developer, you will have to deal only with ___level___, ___message___ and ___code___. All other fields of the ___event___ being handled internaly by DecaLog.

### Simple usage
The simplest way to generate an ___event___ from your code is to use DecaLog as a standard PSR-3 logger. You can do so as soon as all code for `plugins_loaded` WordPress hook is executed (in standard mode) or as soon as `muplugins_loaded` WordPress hook is executed (if the corresponding option is activated in settings).
```php
    
    // Initializes the events logger
    $event_logger = new Decalog\Logger( 'plugin', 'My Plugin', '1.2.3' );
    
    // Logs a debug message
    $event_logger->debug( 'Test message.' );
    
    // Logs an error with an optional error code
    $event_logger->error( 'Page not found.', [ 'code' => 404 ] );

    // Logs an event with an arbitrary level
    $event_logger->log( \PSR\Log\LogLevel::ERROR, 'Error message.' );

```

This way of doing things is quite operational but, to be honest, there is a much, much, better way: writing your own ___listener___!

### Writing a listener
As previously said, a ___listener___ is a piece of code that listens to a specific _perimeter_. You can write a ___listener___ just for your plugin or theme. If your ___listener___ respects [conventions](#conventions) and if your plugin or theme is present in the WordPress directory, it can be released with the next version of DecaLog.

Before writing a ___listener___ your plugin or theme must define actions hooks with `do_action()` function each time a significant condition occurs. Like this:

```php
    /**
    * Fires immediately after a content is deleted.
    *
    * @since 4.4.0
    *
    * @param string $content_id  ID of the deleted content.
    */
    do_action( 'myplugin_delete_content', $content_id );     
```

Once done, you can write your ___listener___ by extending the class `Decalog\Listener\AbstractListener` and put your file in `./wp-content/plugins/decalog/includes/listeners/`. Your ___listener___ class must implement the three following abstract methods:
- `init()` to set the class parameters;
- `is_available()` to verify if your plugin or theme is installed and activated;
- `launch()` to "launch" the listener.

Here is an example that implements a simple ___listener___ able to listen the action defined sooner in this section:

```php
    /**
     * My Plugin listener for DecaLog.
     *
     * Defines methods and properties for My Plugin listener class.
     *
     * @package Listeners
     * @author  Me <me@mail.com>.
     * @since   1.0.0
     */
    class MypluginListener extends AbstractListener {
    
        /**
         * Sets the listener properties.
         *
         * @since    1.0.0
         */
        protected function init() {
            $this->id      = 'my-plugin-slug';
            $this->name    = 'My wonderful plugin';
            $this->class   = 'plugin';
            $this->product = 'My Plugin';
            if ( defined( 'MYPLUGIN_VERSION' ) ) {
                $this->version = MYPLUGIN_VERSION;
            } else {
                $this->version = 'x';
            }
        }
    
        /**
         * Verify if this listener is needed, mainly by verifying if the listen plugin/theme is loaded.
         *
         * @return  boolean     True if listener is needed, false otherwise.
         * @since    1.0.0
         */
        protected function is_available() {
            return defined( 'MYPLUGIN_VERSION' ) && class_exists ( 'MyPluginClass' );
        }
    
        /**
         * "Launch" the listener.
         *
         * @return  boolean     True if listener was launched, false otherwise.
         * @since    1.0.0
         */
        protected function launch() {
            add_action( 'myplugin_delete_content', [ $this, 'delete_content' ], 10, 1 );
            return true;
        }
    
        /**
         * "delete_content" event.
         *
         * @since    1.0.0
         */
        public function delete_content( $content_ID ) {
            $this->logger->info( sprintf ( 'Content ID %s deleted', $content_ID ) );
        }
    
    }  
```

By doing this way, you can fully integrate DecaLog with your plugin or theme. You can even develop a ___listener___ for a plugin or theme you're not the author of - if it has some actions to listen...

## Conventions
To be fully compatible with DecaLog, your ___listener___ (or other pull requests you would like to submit) must respect some rules and adhere to some standards:

### General rules
The file defining the class for a ___listener___ must be named `class-<name>.php` where `<name>` is the class name in lower characters. This file must reside in `./includes/listeners/`. The class name must be in _Upper Camel Case_.

### Events standards

#### Levels
In order to be similar to other log management systems and to maintain consistency between all the DecaLog ___listeners___, the ___levels___ are used as follows:
* `DEBUG` - Only used for events related to application/system debugging. Must not concern standard, important or critical events. _Ex.: "Plugin table xxx updated.", "Textdomain yyy loaded."_.
* `INFO` - Simple informational messages which can be forgotten. _Ex.: "User xxx is logged-out.", "New comment on post yyy."_.
* `NOTICE` - Normal but significant conditions. _Ex.: "The configuration of plugin xxx was modified.", "The database is 70% full."_.
* `WARNING` - A significant condition indicating a situation that may lead to an error if recurring or if no action is taken. _Ex.: "Page not found.", "Comment flood triggered."_.
* `ERROR` - Minor operating error which requires investigation and preventive treatment. _Ex.: "The file could not be opened.", "The feature could not be loaded."_.
* `CRITICAL` - Operating error which requires investigation and corrective treatment. _Ex.: "Uncaught Exception!", "Database error in query xxx."_.
* `ALERT` - Major operating error which requires immediate corrective treatment. _Ex.: "The WordPress database is corrupted."_.
* `EMERGENCY` - A panic condition (unusable system). _Ex.: "The WordPress database is down.", "Parse error: syntax error, unexpected 'if' (T_IF)."_.

#### Codes
If the ___event___ relate to a HTTP condition, the ___code___ must be, as much as possible, the HTTP response code.

The code `0` means: "unknown", "not significant" or "not an error". 

#### Messages
The first 30-40 characters of the message must allow the user to understand, at a glance, what the message is.

### Privacy
DecaLog let its users to set the needed level of privacy. To respects this level, you must use in your ___listener___ the helpers provided by DecaLog. This mainly concerns the names and user IDs in the ___message___ content.

To respect the choices made by DecaLog users, you must use the `get_user()` method in your ___listener___ each time it handles names and user IDs:
```php
    // DO NOT DO THAT, PLEASE:
    $this->logger->info( sprintf ( 'User %1$s done something', $user_ID ) );
    
    // Instead, do that:
    $this->logger->info( sprintf ( 'User %1$s done something', $this->get_user( $user_ID ) ) );
```

### Coding style
When you develop for DECALOG, remember to respect the [WordPress Coding Standards](https://codex.wordpress.org/WordPress_Coding_Standards). If you're using [PHP_CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer) you can enforce standards with [these rules](https://github.com/WordPress/WordPress-Coding-Standards).


> If you think this documentation is incomplete, not clear, etc. Do not hesitate to open an issue and/or make a pull request.
